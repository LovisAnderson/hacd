# *****************************************************************************
#       Copyright (C) 2017      Tom Walther
#                     2017-2018 Lovis Anderson  <lovisanderson@posteo.net>
#                     2017-2018 Benjamin Hiller <hiller@zib.de>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 3 of
#  the License, or (at youroption) any later version.
#                  http://www.gnu.org/licenses/
# *****************************************************************************
import json
import os

from hacd.cut_generators.cut_generators_enum import CutGenerator
from node import Node

import pygraphviz as pgv
import matplotlib.pyplot as plt
import matplotlib.colors as colors
import matplotlib.cm as cmx


class LightNode(object):
    def __init__(self,
                 id,
                 parentID,
                 dict=None,
                 convex_cd=None,
                 halfspace=None,
                 cluster=None):
        self.id = id
        self.halfspace = halfspace
        self.cluster = cluster
        self.parent_id = parentID
        self.children = None
        self.dict = dict
        self.convex_cd = convex_cd


class Tree(object):
    def __init__(self, root_node):
        self.root = root_node
        self.root.dict = self.root.as_dict()
        self.leafes = []
        self.inner_nodes = []

    def dfs(self, nr_cuts):
        nodes_to_decompose = [(self.root, None, None)]
        while nodes_to_decompose:
            current_node = nodes_to_decompose.pop()
            current_node[0].logStatistics()
            if current_node[0].check_abort():
                self.leafes.append(LightNode(
                    current_node[0].id,
                    current_node[0].parent_id,
                    convex_cd=current_node[0].convex_cd,
                    halfspace=current_node[1],
                    cluster=current_node[2],
                    dict=current_node[0].as_dict()
                ))
                continue
            # Find and resolve clusters
            clusters = current_node[0].find_clusters()

            if len(clusters) > 1:
                current_node[0].children = current_node[0].clusters_to_nodes(clusters)
            else:
                cuts = current_node[0].find_cuts(nr_cuts=nr_cuts)
                best_cut = current_node[0].best_cut(cuts)
            if len(clusters) > 1:
                nodes_to_decompose += [(node, None, clusters[i])
                                       for i, node in enumerate(current_node[0].children)]

            else:
                # if the children of the node are generated by a cut, they result by intersection
                # with the halfspace (cut, -1) for children[0] and resp. (cut, 1) for children[1]
                nodes_to_decompose += [(n, (best_cut, 2 * i - 1), None)
                                       for i, n in enumerate(current_node[0].children)]
            self.inner_nodes.append(LightNode(
                current_node[0].id,
                current_node[0].parent_id,
                halfspace=current_node[1],
                cluster=current_node[2],
                dict=current_node[0].as_dict()
            ))

    def as_dict(self):
        d = {node.id: node.dict for node in [self.root] + self.leafes + self.inner_nodes}
        return d


def render_tree_dict(tree_path, outpath=None):
    """
    Method renders ACD_tree dict as returned by ACD_tree.as_dict() (stored in a json).
    :param tree_path: path of tree dict json
    :param outpath: path to save tree. if none tree is saved in same directory as json as tree.png
    :return:
    """
    data = json.load(open(tree_path))
    if not outpath:
        outpath = os.path.join(os.path.dirname(tree_path), 'tree.png')
    root = data['root']
    cm = plt.get_cmap('RdYlGn')
    max_error = root['total_error']
    cNorm = colors.Normalize(vmin=0, vmax=max_error)
    scalarMap = cmx.ScalarMappable(norm=cNorm, cmap=cm)
    G = pgv.AGraph()
    for id, node in data.iteritems():
        node_color = scalarMap.to_rgba(max_error - node['total_error'])
        node_color = colors.rgb2hex(node_color)
        G.add_node(str(id),
                   label='conv_vol: {:.2f}, err: {:.3f}'.format(node['convex_volume'],
                                                                node['total_error']),
                   fillcolor=node_color,
                   style='filled')
    for id, node in data.iteritems():
        if id == 'root':
            continue
        G.add_edge(str(node['parent_id']), str(id))
    G.layout(prog='dot')
    G.draw(outpath)


def build_acd(union_cd,
              convex_cd,
              max_vol_error=0.05,
              max_depth=10,
              cut_generator=CutGenerator.SWEEP,
              nr_cuts=10
              ):

    root_node = Node(
        union_cd,
        convex_cd,
        id='root',
        depth=0,
        parent_id=None,
        tol_rel=max_vol_error,
        tol_abs=None,
        max_depth=max_depth,
        cut_generator=cut_generator
    )

    tree = Tree(root_node)
    tree.dfs(nr_cuts)
    return tree
